#[inline(always)]
unsafe fn cast<const N: usize, T>(x: &[T]) -> &[T; N] {
    &*(x as *const [T] as *const [T; N])
}

#[inline(always)]
unsafe fn cast_mut<const N: usize, T>(x: &mut [T]) -> &mut [T; N] {
    &mut *(x as *mut [T] as *mut [T; N])
}

fn transpose8x8(inm: &[f32; 64], outm: &mut [f32; 64]) {
    for i in 0..8 {
        for j in 0..8 {
            outm[j * 8 + i] = inm[i * 8 + j];
        }
    }
}

const COS_TABLE: [f32; 64] = [
    0.707106781186547524400844362105,
    0.980785280403230449126182236134,
    0.923879532511286756128183189397,
    0.831469612302545237078788377618,
    0.707106781186547524400844362105,
    0.555570233019602224742830813949,
    0.382683432365089771728459984030,
    0.195090322016128267848284868477,
    0.707106781186547524400844362105,
    0.831469612302545237078788377618,
    0.382683432365089771728459984030,
    -0.195090322016128267848284868477,
    -0.707106781186547524400844362105,
    -0.980785280403230449126182236134,
    -0.923879532511286756128183189397,
    -0.555570233019602224742830813949,
    0.707106781186547524400844362105,
    0.555570233019602224742830813949,
    -0.382683432365089771728459984030,
    -0.980785280403230449126182236134,
    -0.707106781186547524400844362105,
    0.195090322016128267848284868477,
    0.923879532511286756128183189397,
    0.831469612302545237078788377618,
    0.707106781186547524400844362105,
    0.195090322016128267848284868477,
    -0.923879532511286756128183189397,
    -0.555570233019602224742830813949,
    0.707106781186547524400844362105,
    0.831469612302545237078788377618,
    -0.382683432365089771728459984030,
    -0.980785280403230449126182236134,
    0.707106781186547524400844362105,
    -0.195090322016128267848284868477,
    -0.923879532511286756128183189397,
    0.555570233019602224742830813949,
    0.707106781186547524400844362105,
    -0.831469612302545237078788377618,
    -0.382683432365089771728459984030,
    0.980785280403230449126182236134,
    0.707106781186547524400844362105,
    -0.555570233019602224742830813949,
    -0.382683432365089771728459984030,
    0.980785280403230449126182236134,
    -0.707106781186547524400844362105,
    -0.195090322016128267848284868477,
    0.923879532511286756128183189397,
    -0.831469612302545237078788377618,
    0.707106781186547524400844362105,
    -0.831469612302545237078788377618,
    0.382683432365089771728459984030,
    0.195090322016128267848284868477,
    -0.707106781186547524400844362105,
    0.980785280403230449126182236134,
    -0.923879532511286756128183189397,
    0.555570233019602224742830813949,
    0.707106781186547524400844362105,
    -0.980785280403230449126182236134,
    0.923879532511286756128183189397,
    -0.831469612302545237078788377618,
    0.707106781186547524400844362105,
    -0.555570233019602224742830813949,
    0.382683432365089771728459984030,
    -0.195090322016128267848284868477,
];

#[inline(always)]
fn idct_1d(m_in: &[f32; 8], m_out: &mut [f32; 8]) {
    for n in 0..8 {
        let mut sum = 0.;
        for k in 0..8 {
            // TODO: do not always use mul_add,
            // since this generates calls to an fma *function* if fma
            // as an instruction is not available for the target.

            // this is going to slow down the code a lot in some cases,
            // since the codegen on the default x86 target is way worse.

            // sum = f32::mul_add(s, m_in[k] * COS_TABLE[8 * n + k], sum)
            sum += m_in[k] * COS_TABLE[8 * n + k];
        }
        m_out[n] = sum * 0.5;
    }
}

const COS_TABLE_INT: [i32; 64] = [
    1048577, 1028428, 968758, 871860, 741456, 582558, 401273, 204568, 1048577, 871860, 401273,
    -204566, -741454, -1028426, -968756, -582556, 1048577, 582558, -401271, -1028426, -741454,
    204568, 968758, 871860, 1048577, 204568, -968756, -582556, 741456, 871860, -401271, -1028426,
    1048577, -204566, -968756, 582558, 741456, -871858, -401271, 1028428, 1048577, -582556,
    -401271, 1028428, -741454, -204566, 968758, -871858, 1048577, -871858, 401273, 204568, -741454,
    1028428, -968756, 582558, 1048577, -1028426, 968758, -871858, 741456, -582556, 401273, -204566,
];

fn int_idct_1d(m_in: &[i32; 8], m_out: &mut [i32; 8]) {
    // using 20 bits of decimal
    const SQRT2_O2: i32 = 741455;

    for n in 0..8 {
        let mut sum = 0;
        for k in 0..8 {
            let s = if k == 0 { SQRT2_O2 } else { 1 << 20 };
            // TODO: do not always use mul_add,
            // since this generates calls to an fma *function* if fma
            // as an instruction is not available for the target.

            // this is going to slow down the code a lot in some cases,
            // since the codegen on the default x86 target is way worse.

            // sum = f32::mul_add(s, m_in[k] * COS_TABLE[8 * n + k], sum)
            // sum += ((s * m_in[k]) >> 20) * COS_TABLE_INT[8 * n + k];

            // would be way better to fuse the multiplications into one

            // sum += s * m_in[k] * COS_TABLE[8 * n + k];

            sum += (((s * m_in[k]) >> 20) * COS_TABLE_INT[8 * n + k]) >> 20;
        }
        // also try / 2 for i32
        m_out[n] = sum >> 1;
    }
}

pub fn idct(m_in: &[f32; 64], m_out: &mut [f32; 64]) {
    unsafe {
        let mut transposed = [0.; 64];
        transpose8x8(m_in, &mut transposed);

        for i in 0..8 {
            idct_1d(
                cast(&transposed[8 * i..][..8]),
                cast_mut(&mut m_out[8 * i..][..8]),
            );
        }

        transpose8x8(m_out, &mut transposed);

        for i in 0..8 {
            idct_1d(
                cast(&transposed[8 * i..][..8]),
                cast_mut(&mut m_out[8 * i..][..8]),
            );
        }

        // TODO just curious if doing the transpose here
        // also works (and removing the first transpose)
    }
}
